---
title: "Tissue simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tissue simulation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  markdown:
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(rRACES)
```

To simulate a tissue the following steps are required:

1.  creation of a tissue;

2.  introduction of cells in the tissue;

3.  actual simulation.

The simulation is managed by an object of the S4 class `Simulation`,
wich allows to program the tissue evolution over time, adding new cells
as far as the simulation progresses. The state of the simulation and
tissue can be visualised using `ggplot`-powered plots.

## Tissue specification

To perform a simulation a new object of class `Simulation` must be
created.

```{r, eval=FALSE}
# Default constructor
sim <- new(Simulation)
```

This automatically builds a 1000x1000-cells tissue - which can host $1$
million cells - and sets the name of the simulation to be
`races_<date>_<hour>`.

A simulation custom name can be specified as it follows.

```{r, eval = TRUE}
# Call your simulation "Test"
sim <- new(Simulation, "Test")
```

In order to save the simulation progresses in the disk and recover it in
the future, use the optional Boolean parameter `save_snapshots`. By
setting `save_snapshots` to `TRUE`, the simulation progresses will be
saved in a directory whose name is the name of the simulation.

```{r, eval = FALSE}
# The progresses of the simulation will saved in the "Test" folder.
# If the directory "Test" already exists an exception is raised.
sim <- new(Simulation, "Test", save_snapshots = TRUE)
```

```{r echo=FALSE, results='hide', message=FALSE, warning=FALSE}
sim$death_activation_level <- 50
```

Class `Simulation` exports a `Simulation$show()` method to get information on the
current object.

```{r, eval}
sim
```

The `sim` object exposes also methods to get information about the
simulation and control it.

```{r}
# Get the simulation directory, i.e., "Test"
sim$get_name()

# Get the tissue size, i.e., c(1000,1000)
sim$get_tissue_size()
```

### Custom tissue

We can change the tissue size and label it with a
name that might appear in some plots.

```{r}
# Set the tissue name and size to different values
sim$update_tissue("Liver", 1200, 900)

# Get the tissue name, i.e., "Liver"
sim$get_tissue_name()

# Get the tissue size, i.e., c(1200,900)
sim$get_tissue_size()
```

## Species specification

In order to simulate the evolution of some species we need to add them
to `sim`. This process defines the evolutionary parameters of the
species.

A *mutant* is a set of cells having the same (potentially unknown) driver
mutations. Cells in the same mutant can have different liveness rates
due to different epigenetic states.

A *species* is a mutant with an optional epigenetic state. At this point in the
simulation, the mutant is just a name (`A`, `B`, ..) that, at a later stage
could be linked to mutations of interest. The epigenome is a binary
feature of a species that is represented by epistates `+`/`-` (positive
and negative status). This is an abstraction, and could represent an
active/inactive state linked to a promoter methylation or, more broadly,
a phenotype. The evolution of mutants is non-reversible (no-back
mutations model), while the evolution among epistates is potentially
reversible.

For example, if we define two mutants `A` and `B` with their epistates
`+`/`-`, we have 4 distinct species: `A+` and `A-`, as well as `B+` and
`B-`.

Hybrid models can be obtained, e.g., a mutant `A` (with no epistates),
together with `B+` and `B-`.

### Evolutionary parameters

We use a notation common in linear birth-death processes. If a species
`A` has no epistates then its stochastic behaviour is defined by the
state-change rates

$$
\begin{align}
\text{(growth)}\quad A & \rightarrow_{\lambda} 2 A \\
\text{(death)}\quad A & \rightarrow_{\delta} \emptyset
\end{align}
$$

where:

-   $\lambda>0$ is a growth rate for cells that duplicate;
-   $\delta>0$ is a death rate for cells that duplicate.

Instead, if the species has epistate `+` (denoted $A_\oplus$) and `-`
(denoted $A_\ominus$), then its stochastic behaviour is defined by the
state-change rates

$$
\begin{align}
\text{(growth +)}\quad A_\oplus & \rightarrow_{\lambda_\oplus} 2 A_\oplus \\
\text{(death +)}\quad A_\oplus & \rightarrow_{\delta_\oplus} \emptyset \\
\text{(growth -)}\quad A_\ominus & \rightarrow_{\lambda_\ominus} 2 A_\ominus \\
\text{(death -)}\quad A_\ominus & \rightarrow_{\delta_\ominus} \emptyset \\
\text{(switch +-)}\quad A_\oplus & \rightarrow_{\epsilon_{+-}} A_\oplus + A_\ominus \\
\text{(switch -+)}\quad A_\ominus & \rightarrow_{\epsilon_{-+}} A_\ominus + A_\oplus
\end{align}
$$

where the rates $\lambda$ and $\delta$ are as above, and $\epsilon_{+-}$
or $\epsilon_{-+}$ are the ratesat which cells of a certain epistate
duplicate and flip the epigenetic marker of one of the progeny.

```{r, eval=TRUE}
sim$add_mutant(name = "A",
               epigenetic_rates = c("+-" = 0.01, "-+" = 0.01),
               growth_rates = c("+" = 0.2, "-" = 0.08),
               death_rates = c("+" = 0.1, "-" = 0.01))

# updated object (counts refer to number of cells of each species)
sim

# Get the simulation species and their rates
sim$get_species()
```

A mutant without epistates could be added as

```{r, eval=FALSE}
# Not run
sim$add_mutant(name = "A", growth_rates = 0.2, death_rates =  0.1)
```

To be able to simulate the model, an initial cell needs to be displaced
in the tissue.

```{r}
# We add one cell of species A+ (mutant A in epistate +) in
# position (500, 500).
sim$place_cell("A+", 500, 500)
```

### Visualisations

We can query the current state of the simulation, and extract the
position of each cell in the tissue.

```{r}
# Counts per species
sim$get_counts()

# Cells position (one so far)
sim$get_cells()
```

These information can be plot. Note that the tissue visualisation uses
hexagonal bins to avoid rastering delays when the simulation uses
thousands of cells.

```{r,  fig.height=4, fig.width=3}
# Piechar for counts
plot_state(sim)

# Spatial distribution for the whole tissue (hexagonal bins)
plot_tissue(sim)
```

> **Note:** since the plots are done with `ggplot` they can be assembled
> and customised.

## Species Evolution

There are 4 ways to let the simulation evolve:

-   advancing until the number of cells in a species reaches a given
    threshold $\theta > 0$;
-   advancing until a new time $t>0$ is reached;
-   advancing until a desired number of firings (of one particular
    event) has occurred;
-   advancing until a formula is not satisfied by the simulation
    status.

### Size-Based Simulation

We can run the simulation up to when we have $\theta > 0$; cells of
species `A+`

```{r,  fig.height=4, fig.width=3}
# Counts per species is now 0
sim$get_counts()

sim$run_up_to_size("A+", 500)

# Counts per species now reports 500 for A+
sim$get_counts()

plot_tissue(sim)
```

### Firing-Based Simulation

The number of times each event has fired is accessible

```{r}
# Get the number of fired event per species
sim$get_firings()
```

A small number of cell deaths have occurred in species `A-` up to this
point, so we can simulate the system until there are 100 of them.

```{r}
sim$run_up_to_event("death", "A-", 100)

# The row "death", for "A" "-" now reports 100
sim$get_firings()
```

```{r,  fig.height=4, fig.width=3}
# Plot the tissue by using 200 bins
plot_tissue(sim, num_of_bins = 200)
```

### Clock-Based Simulation

It is also possible to take the current simulation clock as reference,
and simulate further.

```{r}
# Get the simulation clock
sim$get_clock()

# Run the simulation for other 15 time units
sim$run_up_to_time(sim$get_clock() + 15)

# Get again the simulation clock
sim$get_clock()
```

```{r,  fig.height=4, fig.width=3}
plot_tissue(sim)
```

### Formula-Based Simulation (Advanced)

rRACES implements a first order unquantified logic having variables
representing the cardinality of the species, the number of events
fired in a species (being duplications, deaths, or switches), and
the simulation time. These variables and reals values are summed by
`+`, subtracted by `-`, and multiplied by `*` and form expressions.
The expressions are then compared with the standard semantics by
`>`, `>=`, `==`, `!=`, `<=`, and `<` to form relations.
A formula in this language is either a relation, the conjunction
of two formulas (`&`), or the disjunction of two formulas (`|`).

Any formula in above language expresses a condition on the simulation
status and it can be used as the parameter of the method
`Simulation$run_until()` to let the simulation evolve until
the condition does not hold.

#### Variables

The variables represent one among the following quantities:

-  the cardinality of a species;
-  the number fired event among deaths, duplications and switches in a species;
-  the elapse simulation time.

All above variables can be built by using the method `Simulation$var()`.
When the parameter is the string `"Time"`, the elapsed simulation time
variable is returned.

```{r}
# build a simulation and add two species to it
sim2 <- new(Simulation)
sim2$add_mutant(name = "A",
                epigenetic_rates = c("+-" = 0.01, "-+" = 0.01),
                growth_rates = c("+" = 0.2, "-" = 0.08),
                death_rates = c("+" = 0.1, "-" = 0.01))

# get the variable representing the simulation time
v_time <- sim2$var("Time")

v_time
```

When the parameter is the name of a species,
a variable representing the cardinality of the species is built.

```{r}
# get the variable representing the cardinality of A+ in sim2
va_p <- sim2$var("A+")
va_p

# get the variable representing the cardinality of A- in sim2
va_m <- sim2$var("A-")
va_m
```


Finally, when the parameter is the name of a species followed by
a `.` and the name of an event among `deaths`, `duplications`,
or `switches`, `Simulation$var()` returns
the variable associated with the number of
the corresponding event in the specified species.

```{r}
# get the variable representing the number of epigenetic
# switches from A+
va_ps <- sim2$var("A+.switches")
va_ps

# get the variable representing the number of duplications in A+
sim2$var("A+.duplications")

# get the variable representing the number of deaths in A+
sim2$var("A+.deaths")
```

##### Expressions and Formulas

An expression is one of the following object:

-  a variable, e.g., `sim2$var("A+")`;
-  a numeric value, e.g., `3.4`;
-  the sum of two expressions, e.g., `sim2$var("A+") + 3.4`;
-  the subtraction of two expressions, e.g., `sim2$var("A+") - 3.4`;
-  the multiplication of two expressions, e.g., `sim2$var("A+") * 3.4`.

Two expression can be related by `<=`, `<`, `==`, `!=`, `>` and
`>=`.

A formula is:

-  a relation among two expressions, e.g., `sim2$var("A+")>=2`;
-  the conjunction of two formulas, e.g., `sim2$var("A+")>=2 & sim2$var("A+")<=500`;
-  the disjunction of two formulas, e.g., `sim2$var("A+")>=2 | sim2$var("A+")<=500`.


The method `Simulation$run_until()` takes as the parameter a formula and
lets the simulation evolve until
the formula does not hold.

```{r}
# build a condition stating that the cardinality of A+ doubles
# that of A-
c1 <- va_p >= 2 * va_m
c1

# build a condition that holds when there are more than
# 100000 live cells of mutant A
c2 <- va_p + va_m > 1e5
c2

# build a condition that holds when less than 4000
# epigenetic switches from the species A+ have occured
c3 <- va_ps < 4000
c3

# build a condition that holds when 40 time unit have been
# simulated at least
c4 <- v_time >= 40
c4

# build a condition that holds when c4 and at least one
# among c1, c2, and c3 hold
c5 <- c4 & (c1 | c2 | c3)
c5

# place the initial cell
sim2$place_cell("A+", 500, 500)

# run the simulation while c5 does not hold
sim2$run_until(c5)

sim2
sim2$get_clock()
```

##### Getting Cells (Advanced)

At this point, if we query the simulation we will find more cells (we
use `dplyr` to process query results). For convenience, the getters
accept parameters to subset the tissue.

```{r, message=FALSE}
# load dplyr to use %>%
require(dplyr)

# Get the cells in the tissue at current simulation time
sim$get_cells() %>% head()

# Get the cells in the tissue rectangular sample having
# [500,500] and [505,505] as lower and upper corners, respectively
sim$get_cells(c(500, 500), c(505, 505))  %>% head()

# Get the cells in the tissue having epigenetic state "-"
sim$get_cells(c("A", "B"), c("-")) %>% head()

# Get the cells in the tissue having epigenetic state "-" and,
# at the same time, belonging to rectangular sample bounded by
# [500,500] and [505,505] as lower and upper corners, respectively
sim$get_cells(c(500, 500), c(505, 505), c("A", "B"), c("-"))  %>% head()
```

### Evolving new species

rRACES can select cells from the tissue, randomly for every mutant, or
in a constrained tissue area.

```{r}
# Stochastic sampling from the whole tissue: it can return A+ or A-
sim$choose_cell_in("A")

# Calling it again may result in a different cell
sim$choose_cell_in("A")

# Constrain sampling in the tissue rectangular selection [500,550]x[350,450]
sim$choose_cell_in("A",  c(500, 350), c(550, 450))
```

This feature can be used to program the generation of new species,
mimicking new mutants that generate subclonal expansions.

Imagine we want to add a new mutant `B` with epistates -- and
therefore new species `B+` and `B-` - as descending from `A,`we need to:

-   locate one cell of mutant `A` in the tissue, which is where we
    will inject the new mutant;

-   add the specifics of mutant `B` (via `Simulation$add_mutant()`, as we did for
    `A`);

-   implement the change of the cell of mutant `A` to a cell of
    mutant `B`.

```{r}
# We locate a random cell
cell <- sim$choose_cell_in("A")
cell

# Add mutant
sim$add_mutant(name = "B",
               epigenetic_rates = c("+-" = 0.05, "-+" = 0.05),
               growth_rates = c("+" = 0.3, "-" = 0.3),
               death_rates = c("+" = 0.05, "-" = 0.1))
```

Then we inject the cell, and simulate a little bit.

```{r}
# Mutant injection
sim$mutate_progeny(cell, "B")

# Generated event A -> B either in + or - epistates is now recorded
sim$get_counts()

# New evolution
sim$run_up_to_size("B+", 600)
```

At this point, we can inspect in more details the tissue. It can help to
facet on the species to clearly appreciate the spatial diffusion of the
populations.

```{r,  fig.height=4, fig.width=3}
plot_state(sim)
plot_tissue(sim, num_of_bins = 250)
```

```{r,  fig.height=6, fig.width=6}
# Facet on species via ggplot
library(ggplot2)

plot_tissue(sim, num_of_bins = 250) + facet_wrap(~species)
```

If, at this point in the simulation, we generate a new mutant `C` from
`A` in the rectangle $[450,500]\times [550, 600]$.

```{r}
# Define evolutionary parameters
sim$add_mutant(name = "C",
               epigenetic_rates = c("+-" = 0.1, "-+" = 0.1),
               growth_rates = c("+" = 0.2, "-" = 0.4),
               death_rates = c("+" = 0.1, "-" = 0.01))

# Choose and mutate
sim$mutate_progeny(sim$choose_cell_in("A",  c(450, 550), c(500, 600)), "C")

sim$run_up_to_time(sim$get_clock() + 7)
```

```{r,  fig.height=4, fig.width=3}
plot_state(sim)
plot_tissue(sim, num_of_bins = 250)
```

### Other Operations

##### Injection of Cells over a Tissue

On the tissue, we can inject multiple cells manually; all injected cells
can be retrieved.

```{r}
# Now it will return just the initial cell
sim$get_added_cells()
```

##### Avoiding Drift

Any species that has a non-zero death rate can become extinct
stochastically by *drift*.

Drift makes it difficult to simulate an be confident of what species are
in the model. To facilitate the user, RACES can avoid drift by setting a
*death activation level.* This value is the minimum number of cells that
enables cell death in a species: a cell of species $S$ can die if and
only if $S$ has reached the death activation level at least once during
the simulation.

This threshold holds for all the species and it is set to 1 by default.

```{r}
sim$death_activation_level

# Change death activation level
sim$death_activation_level <- 50
```

## Time Series Data

It is convenient sometimes to plot a time series of a simulation,
reporting species or firing counts over time. Since rRACES is
programmable, it is immediate to make a for-loop algorithm and collect
the simulation data over time.

### Default History-Based Data

However, this is not required because at the end of any `run_to_*`
methods, RACES stores the data about the number of species cells, and
that of event firings. These data can be extracted.

```{r}
# The firings
sim$get_firing_history() %>% head()

# For example, total number of the deaths on `B+` at the end of the
# previous calls of the `run_to_*` methods
sim$get_firing_history() %>%
  filter(event == "death", mutant == "B", epistate == "-")

# The counts
sim$get_count_history() %>% head()
```

The time-series can be plot using `plot_timeseries()`

```{r,  fig.height=4, fig.width=4}
# Time-series plot
plot_timeseries(sim)
```

### Custom Time-Series

If the default time-series is not enough coarse-grained, one can set
`Simulation$history_delta` to increase the sampling rate of
the state (by default, `Simulation$history_delta` is set to $0$).

We show this by re-simulating a tumour with two submutants.

```{r}
# Example time-series on a new simulation, with coarse-grained time-series
sim <- new(Simulation, "Finer Time Series")

sim$history_delta <- 1
sim$death_activation_level <- 100

# A
sim$add_mutant(name = "A",
               epigenetic_rates = c("+-" = 0.01, "-+" = 0.01),
               growth_rates = c("+" = 0.2, "-" = 0.08),
               death_rates = c("+" = 0.1, "-" = 0.01))

sim$place_cell("A+", 500, 500)
sim$run_up_to_size("A+", 400)

# B (linear inside A)
sim$add_mutant(name = "B",
               epigenetic_rates = c("+-" = 0.05, "-+" = 0.05),
               growth_rates = c("+" = 0.3, "-" = 0.3),
               death_rates = c("+" = 0.05, "-" = 0.1))

sim$mutate_progeny(sim$choose_cell_in("A"), "B")

sim$run_up_to_size("B-", 300)

# C (linear inside B)
sim$add_mutant(name = "C",
               epigenetic_rates = c("+-" = 0.1, "-+" = 0.1),
               growth_rates = c("+" = 0.2, "-" = 0.4),
               death_rates = c("+" = 0.1, "-" = 0.01))

sim$mutate_progeny(sim$choose_cell_in("B"), "C")

# D (linear inside A, so branching with C) - same parameters of C
sim$add_mutant(name = "D",
               epigenetic_rates = c("+-" = 0.1, "-+" = 0.1),
               growth_rates = c("+" = 0.2, "-" = 0.4),
               death_rates = c("+" = 0.1, "-" = 0.01))

sim$mutate_progeny(sim$choose_cell_in("A"), "D")

sim$run_up_to_size("D+", 1000)
```

The time-series can be plot using `plot_timeseries()`.

```{r,  fig.height=4, fig.width=4}
# Time-series plot
plot_timeseries(sim)

# Logscale helps seeing the different effective growth rates
plot_timeseries(sim) + ggplot2::scale_y_log10()
```

### Muller Plot

We can also get a Muller plot of the evolution using
[ggmuller](https://CRAN.R-project.org/package=ggmuller).

```{r,  fig.height=4, fig.width=6, message=FALSE, warning=FALSE}
# default Muller plot
plot_muller(sim)
```

In this case every population is annotated as a descendant of the
ancestor mutant. Note however that reversible espistates do not fit a
traditional Muller plot because they violate the no-back mutation model.

In this case, _rRACES_ will show first the epistate that was randomly
injected in the simulation, and the second will result by linear. This
is not a completely correct perspective of the simulation time-series;
still, it help understand trends.

```{r,  fig.height=4, fig.width=6, message=FALSE, warning=FALSE}
# Custom Mullers
clock <- sim$get_clock()

plot_muller(sim) + ggplot2::xlim(clock * 3/4, clock)

plot_muller(sim) +
  ggplot2::xlim(clock * 3/4, clock) +
  ggplot2::scale_y_log10()
```

## Time-Varying Evolutionary Rates

You can model the fact that the rates of one species. For instance, this
happens when a population is subject to a targeted treatment.

Considering the example above, where `C` and `D` have the same rates, we
increase the death rate of both `C+` and `C-` species, as well as `B+`
and `B-`.

```{r,  fig.height=4, fig.width=6, message=FALSE, warning=FALSE}
# Current rates
sim

# Raise the death rate levels
sim$update_rates("B+", c(death = 3))
sim$update_rates("B-", c(death = 3))
sim$update_rates("C+", c(death = 3))
sim$update_rates("C-", c(death = 3))

# Now D will become larger
sim$run_up_to_size("D+", 6000)

# Current state
sim

# This now show the change in rates
clock <- sim$get_clock()
plot_muller(sim) + ggplot2::xlim(clock * 3/4, clock)

plot_muller(sim) +
  ggplot2::xlim(clock * 3/4, clock) +
  ggplot2::scale_y_log10()
```

